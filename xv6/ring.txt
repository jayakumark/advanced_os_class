=============================================================
Ring Buffer API
=============================================================

struct ring is opaque for users of the API

each ring has exactly one writer process and exactly one reader
process

struct ring *ring_attach (uint token)

  token is the name of the ring that we want to create or attach to;
  returns NULL on fail

int ring_size (uint token)

  returns total capacity of the named ring in bytes

int ring_detach (uint token);

  return 0 on successful detach, -1 otherwise

void *ring_write_reserve (ring *r, int bytes)

  reserves bytes for writing

  returns base of reserved region on success, NULL on failure to
  reserve, and (void *)-1 on getting a bad request (not 4-byte aligned
  or for a number of bytes that exceeds the size of the ring buffer)

  NOTE: reserved regions may wrap around the end of the ring

  consecutive successful calls to ring_write_reserve are guaranteed to
  return pointers to consecutive regions of memory except that
  wrapping will occur at the end of the ring

void ring_write_notify (ring *r, int bytes)

  notifies the reader that written bytes are available for consumption

  it is an error to call write_notify with more bytes than have been
  reserved

void *ring_read_reserve (ring *r, int bytes)

  reserves bytes for reading

  returns base of reserved region on success, NULL on failure to
  reserve, and (void *)-1 on getting a bad request (not 4-byte aligned
  or for a number of bytes that exceeds the size of the ring buffer)

  NOTE: reserved regions may wrap around the end of the ring

  consecutive successful calls to ring_read_reserve are guaranteed to
  return pointers to consecutive regions of memory except that
  wrapping will occur at the end of the ring

void ring_read_notify (ring *r, int bytes)

  notifies the writer that read bytes are available for production

  it is an error to call read_notify with more bytes than have been
  reserved

void ring_write (ring *r, void *buf, int bytes)
void ring_read (ring *r, void *buf, int bytes)

  these provide pipe-like semantics and are built on top of the
  primitive operations

  Question: should these be blocking operations?

=============================================================
Ring Buffer Internals
=============================================================

ring size should be compile-time configurable, and must be power-of-2
number of pages

the ring should use the xv6 shmget() API to reserve shared memory

head and tail pointers each go at the start of their own cache line in
the shared memory page immediately following the ring

head and tail are unsigned 32-bit integers

struct ring {
       unsigned tok;
       void *buf;
}

=============================================================
