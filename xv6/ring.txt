=============================================================
Ring Buffer API
=============================================================

struct ring is opaque for users of the API

each ring has exactly one writer process and exactly one reader
process

struct ring *ring_attach (uint token)

  token is the name of the ring that we want to create or attach to;
  returns NULL on fail

int ring_detach (uint token);

  return 0 on successful detach, -1 otherwise

void *write_reserve (ring *r, int bytes)

  reserves bytes for writing

  returns base of reserved region on success, NULL on failure to
  reserve, and (void *)-1 on getting a bad request (not 4-byte aligned
  or for a number of bytes that exceeds the size of the ring buffer)

void write_notify (ring *r, int bytes)

  notifies the reader that written bytes are available for consumption

  it is an error to call write_notify with more bytes than have been
  reserved

void *read_reserve (ring *r, int bytes)

  reserves bytes for reading

  returns base of reserved region on success, NULL on failure to
  reserve, and (void *)-1 on getting a bad request (not 4-byte aligned
  or for a number of bytes that exceeds the size of the ring buffer)

void read_notify (ring *r, int bytes)

  notifies the writer that read bytes are available for production

  it is an error to call read_notify with more bytes than have been
  reserved

=============================================================
Ring Buffer Internals
=============================================================

ring size should be compile-time configurable, and must be power-of-2
number of pages

the ring should use the xv6 shmget() API to reserve shared memory

head and tail pointers each go at the start of their own cache line in
the shared memory page immediately following the ring

head and tail are unsigned 32-bit integers

struct ring {
       unsigned tok;
       void *buf;
}

=============================================================
